- how do we handle nested branches
- case:
  - br0 -> predicted not taken
  - ...
  - br1 -> predicted not taken
  - ...
  - br1 -> mispredicted
  - we need to reroll to the state of when we decoded br1
- snapshots for each branch
- branches get allocated a branch id and an associated snapshot buffer
- on misprediction:
  - copy snapshot into arch2spec map
  - kill all instruction in between mispredicted branch and allocation head
- maybe there is a solution using bank switching instead of real register files
- branch id allocation using head tail sequential allocation
- on misprediction all younger branches are killed


- arch2state points to physical registers behind tail
- allocation head might hit them
- solutions:
  - non-sequential allocation
    - allocatable physical registers are kept in free list
    - instructions remember the ealier alias for their destination and deallocate it on commit
    - instructions are marked under which branch they are
    - draw-back: 
      - on branch misprediction the whole rob needs to be scanned to kill instructions
      - the allocation needs to keep track of all physical registers independently -> 128 x 7-bit ?
    - advantage:
      - we are guaranteed to allocate if a physical register is available
  - sequential allocation with skipping
    - we skip (stall and increment head) physical registers which are in the arch2state map
      - physical registers which contain needed state are kept
    - branch misprediction just has to move the head to the rob entry next to the mispredicted branches rob entry
    - advantage:
      - branch misprediction and allocation are super simple
    - disadvantage:
      - the whole arch2state map has to be read and each entry compared to the current head to see if the allocation is allowed
      - stalls are necessary each time the head points to a state-holding physical register 
        - look-ahead can reduce performance hit